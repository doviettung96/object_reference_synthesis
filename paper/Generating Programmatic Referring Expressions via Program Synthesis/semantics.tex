\section{Referring Relational Programs}

\textbf{Scene graph representation of images.}
%
%\aws{do we need a complicated n-ary formlalization -- my understanding is all predicates are 1-2-ary}
We represent images via \emph{scene graphs} $G \in \graphs$. Vertices in $G$ are objects in the image, and edges encode relations between objects. Unary relations represent attributes such as color and shape, and binary relations capture spatial information between objects---above, left, right, and the like. Abstractly, we think of $G$ as a set of relations over objects:
\begin{align*}
G=\set{\rho_i(o^i_1, \dots, o^i_{n_i})}_{i=1}^n,
\end{align*}
where $\rho_i\in\mathcal{R}$. Relations $\rho(o_1,...,o_n)$ can be certain, uncertain, or absent. Certain are guaranteed to be in the graph, absent relations are guaranteed to not be in the graph, and uncertain relations may or may not be in the graph. We represent this decomposition by writing $G = G_+ \sqcup G_?$ as the \emph{disjoint union} of the certain relations $G_+$ and the uncertain relations $G_?$; absent relations are omitted.

\textbf{Relational programs.}
%
Our search space consists of \emph{relational programs}, which we view as sets of relations over variables. More precisely, let $\vars$ be a finite set of variables, with $\tvar \in \vars$ a \emph{target variable} representing the object being referred to. A relational program has the form:
\begin{align*}
P = \bigwedge_{i=1}^m\rho_i(z^i_1,...,z^i_{n_i}).
\end{align*}
%where \emph{at least} one $z_j^i$ is the target variable $\tvar$.
A \emph{valuation} $v \in \valuations$ is a function $v : \vars \to \objects$ that maps each variable to an object in the scene. Given a valuation, we can \emph{ground} the variables in a program using $\interp{\cdot}$:
%\aws{we might want to say what [[]] means for an ML audience}
\footnote{We use the notation $\interp{P}_v$ to denote the \emph{semantics} of a program $P$---i.e., the output obtained by evaluating $P$. In our case, $P$ evaluates into a logical formula over objects, which can be interpretered as a function mapping scene graphs to true/false.} 
\begin{align*}
\interp{P}_v=\bigwedge_{i=1}^m\rho_i(v(z^i_1),...,v(z^i_{n_i}))
\end{align*}
We will equivalently interpret $\interp{P}_v$ as the set of concrete relationships in the conjunction---i.e.,
\begin{align*}
\interp{P}_v&=\left\{\rho_i(v(z^i_1),...,v(z^i_{n_i}))\right\}_{i=1}^m
\end{align*}
In this case, the grounding $\interp{\cdot}$ converts $P$ into a set of predicates over objects. Then we can treat $\interp{P}_v : \graphs \to \bool$, where $\bool=\{\text{true},\text{false}\}$, as a Boolean function over scene graphs defined so that
\begin{align*}
\interp{P}_v(G)=(\interp{P}_v \subseteq G),
\end{align*}
i.e., $\interp{P}_v(G)$ is true if and only if all of the relationships in $\interp{P}_v$ are also contained in $G$.
\begin{definition}
\rm
A valuation $v\in\mathcal{V}$ is \emph{valid} for relational program $P$ and scene graph $G$ iff $\interp{P}_v(G)=\text{true}$.
\end{definition}
We denote the set of all valid valuations for $P$ in $G$ by
\begin{align*}
\interp{P}_G = \set{v \in \valuations \mid \interp{P}_v(G)}.
\end{align*}

\textbf{Referring relational programs.}
%
Our goal is to generate a relational program that satisfies the properties of a referring expression \cite{golland2010game,kazemzadeh2014referitgame}. Given a scene and an object $\tobj$ in that scene, a referring expression is a natural language caption that uniquely identifies $\tobj$. Figure~\ref{fig:example} shows an example of an image together with referring relational programs that identify the target object in that image, and Figure~\ref{fig:graph} shows an example of a scene graph (ignoring the gray variable nodes).

%\aws{i think we should prominently emphasize that graphs can be easily generated by a CNN -- here and in the intro as well}
We study a \emph{symbolic variant} of this problem---i.e., (i) we assume the image is given as a scene graph $G$ (e.g., these can be constructed using deep learning~\cite{redmon2016you,krishna2017visual,yi2018neural,mao2019neuro}), and (ii) our referring expressions are relational programs that uniquely identify $\tobj$. More precisely, given a scene graph $G$ and an object $\tobj$ in $G$, we want to construct a relational program $P$ such that $\tvar$ \emph{must} refer to $\tobj$ in the context of $G$.

\begin{definition}\label{def:refexpr}
\rm
Given scene graph $G$ and target object $\tobj$ in $G$, $P$ is a \emph{referring relational program} for $\tobj$ in $G$ if (i) $\interp{P}_{G_+}\neq\varnothing$, and (ii) for all $v \in \interp{P}_G$, $v(\tvar) = \tobj$.
\end{definition}

Intuitively, a referring relational program must (i) have at least one certain interpretation, and (ii) all interpretations must refer to the target object, \emph{regardless of the value of uncertain relations}. In the rest of this paper, we assume $\tobj$ is encoded in $G$ via a unary \emph{target} relation, and use the predicate $\rrp{G}{P}$ to indicate $P$ is a referring relational program for the encoded $\tobj$ in $G$.
